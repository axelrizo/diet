# Diet Project - TDD AI Development Guidelines

## ðŸš¨ TDD FIRST - Quick Reference for AI Agents

### ï¿½ MANDATORY TDD WORKFLOW

**RED â†’ GREEN â†’ REFACTOR - ALWAYS!**

1. **ðŸ”´ Write failing test FIRST**
2. **ðŸŸ¢ Write minimal code to pass**
3. **ðŸ”µ Refactor while keeping tests green**

### ðŸ“– Before You Start

1. **Read TDD Rules**: Check `.ai_rules.md` and `.ai_config.json`
2. **Understand Context**: Phoenix LiveView app for diet/nutrition tracking
3. **Follow TDD**: Write test first, ALWAYS!

### ðŸ“ File Structure

```
lib/
â”œâ”€â”€ diet/              # Business logic contexts
â”œâ”€â”€ diet_web/          # Web interface
â”‚   â”œâ”€â”€ live/         # LiveView modules
â”‚   â”œâ”€â”€ components/   # Reusable components
test/                 # TDD tests (mirror lib structure)
â”œâ”€â”€ diet/             # Context tests
â”œâ”€â”€ diet_web/         # Web tests
â””â”€â”€ support/          # Test helpers, factories
```

### ðŸŽ¯ TDD Patterns

#### Context Function TDD

```elixir
# 1. Write failing test first
describe "create_food/2" do
  test "returns a food when valid params" do
    valid_attrs = %{name: "Apple", protein: 0.3}
    assert {:ok, %Food{}} = Diets.create_food(valid_attrs)
  end
end

# 2. Implement minimal code
def create_food(attrs \\ %{}) do
  %Food{}
  |> Food.changeset(attrs)
  |> Repo.insert()
end

# 3. Refactor for better design
```

#### LiveView TDD Structure

```elixir
# 1. Test the behavior first
test "saves new food on valid submission", %{conn: conn} do
  {:ok, lv, _html} = live(conn, ~p"/foods/new")

  assert lv
         |> form("#food-form", food: @valid_attrs)
         |> render_submit()

  assert_patch(lv, ~p"/foods")
end

# 2. Implement event handler
def handle_event("save", %{"food" => food_params}, socket) do
  case Diets.create_food(food_params) do
    {:ok, food} ->
      {:noreply, socket |> put_flash(:info, "Success") |> push_patch(to: ~p"/foods")}
    {:error, changeset} ->
      {:noreply, assign(socket, :form, to_form(changeset))}
  end
end
```

### âš¡ TDD Quick Checks

- [ ] **Test written first** (RED phase)
- [ ] **Test fails for right reason**
- [ ] **Minimal code to pass** (GREEN phase)
- [ ] **Refactored for quality** (REFACTOR phase)
- [ ] **95%+ test coverage maintained**
- [ ] **Test names read like specifications**

### ðŸš¨ TDD Red Flags

âŒ Writing any production code before tests
âŒ Skipping the failing test verification
âŒ Writing multiple failing tests at once
âŒ Testing implementation instead of behavior
âŒ Ignoring refactor opportunities

### ðŸ§ª Test Categories (TDD Pyramid)

- **Unit Tests** (Most): Contexts, schemas, utilities
- **Integration Tests** (Some): LiveView, controllers
- **E2E Tests** (Few): Complete workflows

### ðŸ”§ TDD Tools Setup

```elixir
# mix.exs
{:ex_unit, "~> 1.0", only: :test},
{:ex_machina, "~> 2.7", only: :test},
{:phoenix_test, "~> 0.2", only: :test},
{:mox, "~> 1.0", only: :test},
{:excoveralls, "~> 0.16", only: :test}
```

### ðŸ“Š TDD Workflow Example

**Feature: Edit Food**

1. **RED**: Write test for edit food functionality
2. **GREEN**: Create minimal edit LiveView
3. **REFACTOR**: Improve code quality
4. **RED**: Test validation errors
5. **GREEN**: Add validation handling
6. **REFACTOR**: Extract reusable components

### ðŸŽª Common TDD Anti-Patterns

- Writing "happy path" tests only
- Mocking everything instead of testing integration
- Writing tests that test the framework
- Overly complex test setup

### ðŸ“š TDD Resources

- **Test File Naming**: `*_test.exs`
- **Factory Usage**: `insert(:food, name: "Apple")`
- **Mock Usage**: `expect(MockAPI, :call, fn -> {:ok, data} end)`

---

**Remember: If you haven't written a failing test first, you're not doing TDD!**

_Always refer to `.ai_rules.md` for complete TDD guidelines_
