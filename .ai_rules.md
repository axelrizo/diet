# AI Agent Rules and Guidelines - TDD Focused

This document contains the rules, conventions, and guidelines that AI agents should follow when working on this Phoenix/Elixir project with a **Test-Driven Development (TDD)** approach.

## Project Overview

- **Project Type**: Phoenix LiveView Application
- **Language**: Elixir
- **Framework**: Phoenix Framework with LiveView
- **Database**: PostgreSQL with Ecto
- **Frontend**: TailwindCSS, Alpine.js (via Phoenix LiveView)
- **Testing**: ExUnit, ExMachina, Phoenix Test
- **Development Approach**: **Test-Driven Development (TDD)**
- **Clear Boundaries**: When logic grows and we need a new module we refactor its behavior to send it inside

## ðŸš¨ TDD MANDATORY WORKFLOW

### Red-Green-Refactor Cycle

**ALWAYS follow this cycle for ANY code changes:**

1. **ðŸ”´ RED**: Write a failing test first

   - Write the minimum test that describes the desired behavior
   - Run the test to confirm it fails for the right reason
   - The test should fail because the functionality doesn't exist yet

2. **ðŸŸ¢ GREEN**: Write the minimum code to make the test pass

   - Implement only what's needed to make the test pass
   - Don't worry about perfect code yet
   - Focus on making the test green quickly

3. **ðŸ”µ REFACTOR**: Improve the code while keeping tests green
   - Clean up the code
   - Remove duplication
   - Improve design and readability
   - Ensure all tests still pass

## Boundaries with TDD

Separate boundaries when they are obvious in internal modules.

Try to have one assert per test, using describe blocks with setup for multiple, use setup private functions to keep them organized.

### TDD Rules for AI Agents

1. **NO CODE WITHOUT TESTS**: Never write production code without a failing test first
2. **TEST FIRST, ALWAYS**: Start every feature/change with a test
3. **MINIMAL IMPLEMENTATION**: Write only enough code to make tests pass
4. **ONE FAILING TEST**: Don't write multiple failing tests at once
5. **REFACTOR CONTINUOUSLY**: Clean up code after each green phase

## Code Style and Conventions

### Elixir/Phoenix Conventions

1. **Module Naming**: Follow Elixir conventions

   - Context modules: `Diet.Contexts.ModuleName`
   - LiveView modules: `DietWeb.ModuleNameLive.Action`
   - Schema modules: `Diet.Contexts.SchemaName`

2. **File Structure**: Follow Phoenix conventions

   - Contexts in `lib/diet/`
   - Web modules in `lib/diet_web/`
   - LiveViews in `lib/diet_web/live/`
   - Tests mirror the lib structure in `test/`

3. **Function Naming**:

   - Use snake_case for function names
   - Use descriptive names that indicate purpose
   - Public functions should be documented with `@doc`

4. **Pattern Matching**: Prefer pattern matching over conditionals where appropriate

5. **Pipe Operator**: Use the pipe operator `|>` for data transformation chains

### TDD-Specific Testing Conventions

1. **Test File Naming**:

   - Context tests: `test/diet/contexts/context_name_test.exs`
   - LiveView tests: `test/diet_web/live/live_name_test.exs`
   - Schema tests: `test/diet/contexts/schema_name_test.exs`

2. **Test Organization**:

   ```elixir
   defmodule Diet.DietsTest do
     use Diet.DataCase

     alias Diet.Diets

     # generic describe block with generic scenarios
     describe "create_food/2" do
      test "registers a food when valid attrs" do
        # assert
      end

      test "returns a changeset when invalid attrs" do
        # assert
      end
     end

     # specific scenario with multiple asserts just when necessary, when it has 2 or 3 assert we can have it in a generic describe block
     describe "create_food/2 when food is created successfully" do
      # specific setup for each assert
      setup do
      # setup for scenario
      end

      test "returns ok with food" do
      # just one assert
      end

      test "returned food is inserted" do
      # another assert in behavior
      end
   end
   ```

3. **Test Naming**: Use descriptive names that explain behavior, not implementation

## TDD Implementation Workflow

### For Context Functions (Business Logic)

1. **Start with Context Test**:

   ```elixir
   describe "create_food/1" do
    test "creates food when valid attrs" do
      valid_attrs = %{name: "Apple", protein: 0.3, carbs: 14.0, fat: 0.2}

      assert {:ok, %Food{} = food} = Diets.create_food(valid_attrs)
      assert food.name == "Apple"
      assert food.protein == Decimal.new("0.3")
    end
   end
   ```

2. **Run Test (RED)**: Ensure it fails because function doesn't exist

3. **Implement Function (GREEN)**:

   ```elixir
   def create_food(attrs \\ %{}) do
     %Food{}
     |> Food.changeset(attrs)
     |> Repo.insert()
   end
   ```

4. **Refactor**: Improve implementation while keeping tests green

### For LiveView Features

1. **Start with LiveView Test**:

   ```elixir
   test "saves new food on valid submission", %{conn: conn} do
     {:ok, lv, _html} = live(conn, ~p"/foods/new")

     assert lv
            |> form("#food-form", food: @valid_attrs)
            |> render_submit()

     assert_patch(lv, ~p"/foods")
     assert has_element?(lv, "#flash", "Food created successfully")
   end
   ```

2. **Run Test (RED)**: Watch it fail

3. **Implement LiveView (GREEN)**: Add minimal event handler

4. **Refactor**: Clean up implementation

### For Database Schemas

1. **Start with Schema Test**:

   ```elixir
   test "changeset with valid attributes" do
     changeset = Food.changeset(%Food{}, @valid_attrs)
     assert changeset.valid?
   end
   ```

2. **Implement Schema**: Add changeset function

3. **Test Edge Cases**: Invalid data, validations, etc.

## LiveView TDD Specific Rules

### State Management with TDD

1. **Test Socket State**:

   ```elixir
   test "mount assigns initial state" do
     {:ok, socket} = mount(%{}, %{}, %Phoenix.LiveView.Socket{})

     assert socket.assigns.foods == []
     assert socket.assigns.page_title == "Listing Foods"
   end
   ```

2. **Test Event Handling**:

   ```elixir
   test "validates event updates form with errors" do
     socket = %Phoenix.LiveView.Socket{assigns: %{food: %Food{}}}

     {:noreply, updated_socket} =
       handle_event("validate", %{"food" => %{"name" => ""}}, socket)

     assert updated_socket.assigns.form.errors[:name]
   end
   ```

### Template Testing

1. **Test Rendered Output**:

   ```elixir
   test "renders food form" do
     assigns = %{form: to_form(Food.changeset(%Food{}, %{}))}

     html = render_component(&FoodFormComponent.render/1, assigns)

     assert html =~ "Name"
     assert html =~ "Protein"
   end
   ```

## Database and Ecto TDD Rules

### Schema Testing

1. **Test Validations First**:

   ```elixir
   test "returns invalid changeset when no name" do
     changeset = Food.changeset(%Food{}, %{protein: 1.0})
     refute changeset.valid?
     assert "can't be blank" in errors_on(changeset).name
   end
   ```

2. **Test Constraints**:
   ```elixir
   test "returns invalid changeset when negative protein value" do
     changeset = Food.changeset(%Food{}, %{protein: -1.0})
     refute changeset.valid?
   end
   ```

### Migration Testing

## Testing Requirements (TDD Focus)

### Test Coverage and Quality

1. **Minimum 95% Test Coverage**: With TDD, this should be natural
2. **Test Pyramid**:

   - Many unit tests (contexts, schemas)
   - Some integration tests (LiveView)
   - Few end-to-end tests

3. **Test Categories**:
   - **Unit Tests**: Context functions, schemas, utilities
   - **Integration Tests**: LiveView interactions, controllers
   - **Feature Tests**: Complete user workflows

### Test Data Strategy

1. **Use ExMachina for Data Generation**:

   ```elixir
   # In test/support/factory.ex
   def food_factory do
     %Food{
       name: sequence(:name, &"Food #{&1}"),
       protein: Decimal.new("#{:rand.uniform(50)}"),
       carbs: Decimal.new("#{:rand.uniform(100)}"),
       fat: Decimal.new("#{:rand.uniform(30)}")
     }
   end
   ```

2. **Avoid Test Data Coupling**: Each test should be independent

### Mocking and External Dependencies

1. **Use Mox for External Services**:
   ```elixir
   # Mock external API calls
   expect(MockNutritionAPI, :get_nutrition_data, fn _food ->
     {:ok, %{protein: 10, carbs: 20, fat: 5}}
   end)
   ```

## TDD Security Guidelines

### Security-First Testing

1. **Test Input Validation**:

   ```elixir
   test "rejects when malicious input" do
     malicious_attrs = %{name: "<script>alert('xss')</script>"}
     changeset = Food.changeset(%Food{}, malicious_attrs)
     # Test that malicious input is sanitized
   end
   ```

2. **Test Authorization**:
   ```elixir
   test "does not authorize to edit food when user has not permissions" do
     # Test that proper authorization is enforced
   end
   ```

## TDD Performance Considerations

### Performance Testing

1. **Test Query Performance**:

   ```elixir
   test "performs well when large dataset" do
     # Create large dataset
     insert_list(1000, :food)

     # Measure query time
     {time, _result} = :timer.tc(fn -> Diets.list_foods() end)
     assert time < 100_000 # microseconds
   end
   ```

## Error Handling with TDD

### Test-Driven Error Handling

1. **Test Error Scenarios First**:

   ```elixir
   describe "get_food!/1" do
    test "raises when food doesn't exist" do
      assert_raise Ecto.NoResultsError, fn ->
        Diets.get_food!(999)
      end
    end
   end
   ```

2. **Test Error Recovery**:
   ```elixir
   test "handles database connection errors gracefully" do
     # Test what happens when DB is unavailable
   end
   ```

## TDD Documentation Requirements

### Documentation-Driven by Tests

1. **Tests as Documentation**: Tests should clearly show how to use the code
2. **Readable Test Names**: Tests should read like specifications
3. **Example-Driven Docs**: Use test examples in documentation

## TDD-Specific Project Rules

### Food Management TDD

1. **Nutrition Validation Testing**:
   ```elixir
   test "validates nutrition values when some are non-negative decimals" do
     invalid_attrs = %{protein: -1, carbs: "invalid", fat: nil}
     changeset = Food.changeset(%Food{}, invalid_attrs)
     refute changeset.valid?
   end
   ```

### Form Handling TDD

1. **Real-time Validation Testing**:

   ```elixir
   test "validates input when input change" do
     {:ok, lv, _html} = live(conn, ~p"/foods/new")

     html = lv |> element("#food-form") |> render_change(%{food: %{name: ""}})

     assert html =~ "can&#39;t be blank"
   end
   ```

## TDD Code Review Checklist

When implementing features with TDD, ensure:

- [ ] **Tests written first** before any production code
- [ ] **Red-Green-Refactor cycle** followed for each change
- [ ] **Test coverage** is high (95%+)
- [ ] **Tests are readable** and act as documentation
- [ ] **Edge cases** are tested
- [ ] **Error scenarios** are covered
- [ ] **Integration points** are tested
- [ ] **Performance** implications are tested
- [ ] **Security** concerns are tested
- [ ] **Refactoring** maintains green tests

## TDD Anti-Patterns to Avoid

1. **Writing code before tests**
2. **Writing multiple failing tests at once**
3. **Testing implementation details instead of behavior**
4. **Ignoring refactor phase**
5. **Writing tests after code is "done"**
6. **Overly complex test setup**
7. **Testing framework code instead of your code**

## TDD Tools and Setup

### Required Testing Tools

```elixir
# In mix.exs
{:ex_unit, "~> 1.0", only: :test},
{:ex_machina, "~> 2.7", only: :test},
{:phoenix_test, "~> 0.2", only: :test},
{:mox, "~> 1.0", only: :test},
{:excoveralls, "~> 0.16", only: :test}
```

### Test Configuration

```elixir
# In config/test.exs
config :diet, :test_mode, true
config :diet, Diet.Repo,
  database: "diet_test#{System.get_env("MIX_TEST_PARTITION")}",
  pool: Ecto.Adapters.SQL.Sandbox
```

This TDD-focused approach ensures high-quality, well-tested, and maintainable code through disciplined test-first development.

### LiveView Specific Rules

1. **State Management**:

   - Keep socket assigns minimal and focused
   - Use temporary assigns for large data that doesn't need persistence
   - Prefer computed values over stored state when possible

2. **Event Handling**:

   - Use descriptive event names (e.g., "validate", "save", "delete")
   - Always return proper tuples: `{:noreply, socket}` or `{:reply, result, socket}`

3. **Templates**:
   - Use HEEx templates with proper component structure
   - Prefer function components for reusable UI elements
   - Use proper assigns validation with `attr/3`

### Database and Ecto Rules

1. **Migrations**:

   - Always include rollback instructions
   - Use descriptive migration names
   - Add indexes for foreign keys and frequently queried fields

2. **Schemas**:

   - Define proper validations in changesets
   - Use cast/3 and validate\_\* functions appropriately
   - Document schema fields with comments when needed

3. **Queries**:
   - Prefer Ecto.Query over raw SQL
   - Use preloading for associations
   - Add proper error handling for database operations

## Testing Requirements

1. **Test Coverage**: Maintain high test coverage (aim for >80%)

2. **Test Types**:

   - Unit tests for contexts and business logic
   - LiveView tests for user interactions
   - Integration tests for critical flows

3. **Test Data**:

   - Use ExMachina for test data generation
   - Avoid hardcoded test data when possible
   - Clean up test data properly
   - Use setup callbacks for tests with multiple asserts

4. **Test Naming**: Use descriptive test names that explain the behavior being tested

   - The format for describe blocks is the next one for generic, scenarios where we have less asserts to do:
     `describe "{function/arity}" do`

   - The format for specific scenarios is the next one:
     `describe "{function/arity} when {scenario}" do`
     `when` is mandatory

   - The format for test is the next one:
     `{action} {statement} when {scenario} do`
     if is inside a describe block with a current scenario avoid having a nested one, instead create another describe block with scenario

## Security Guidelines

1. **Input Validation**:

   - Always validate user input in changesets
   - Use Phoenix built-in CSRF protection
   - Sanitize HTML output when needed

2. **Authentication/Authorization**:
   - Implement proper user authentication
   - Use plugs for authorization checks
   - Don't expose sensitive data in assigns

## Performance Considerations

1. **Database**:

   - Use appropriate indexes
   - Avoid N+1 queries with preloading
   - Use pagination for large datasets

2. **LiveView**:
   - Use `temporary_assigns` for large data
   - Implement proper debouncing for search/validation
   - Optimize re-renders with targeted DOM updates

## Error Handling

1. **Error Patterns**:

   - Use `{:ok, result}` and `{:error, reason}` tuples consistently
   - Handle edge cases explicitly
   - Provide meaningful error messages to users

2. **Logging**:
   - Use appropriate log levels
   - Include relevant context in log messages
   - Don't log sensitive information

## Documentation Requirements

1. **Module Documentation**:

   - Add `@moduledoc` to all public modules
   - Document the purpose and main functionality

2. **Function Documentation**:

   - Add `@doc` to all public functions
   - Include examples for complex functions
   - Document expected inputs and outputs

3. **Code Comments**:
   - Add comments for complex business logic
   - Explain "why" not "what" when commenting

## Deployment and Environment

1. **Configuration**:

   - Use environment variables for configuration
   - Don't commit secrets to version control
   - Use proper config files (dev.exs, prod.exs, etc.)

2. **Dependencies**:
   - Keep dependencies up to date
   - Use specific version constraints
   - Document any custom or unusual dependencies

## Specific Project Rules

1. **Food Management**:

   - All food items must have proper nutritional validation
   - Use decimal types for nutritional values (not floats)
   - Implement proper error handling for food operations

2. **Forms**:

   - Always include proper validation feedback
   - Use Phoenix form helpers consistently
   - Implement real-time validation where appropriate

3. **Navigation**:
   - Use LiveView navigation (`push_patch`, `push_redirect`) appropriately
   - Maintain proper breadcrumbs and page titles
   - Ensure back button functionality works correctly

## Code Review Checklist

When implementing features, ensure:

- [ ] Code follows Elixir/Phoenix conventions
- [ ] Tests are included and passing
- [ ] Documentation is updated
- [ ] Error handling is proper
- [ ] Security considerations are addressed
- [ ] Performance impact is considered
- [ ] Database migrations are reversible
- [ ] User experience is intuitive

## Common Patterns to Follow

1. **Context Functions**:

   ```elixir
   def create_food(attrs \\ %{}) do
     %Food{}
     |> Food.changeset(attrs)
     |> Repo.insert()
   end
   ```

2. **LiveView Mount**:

   ```elixir
   def mount(params, session, socket) do
     {:ok, assign(socket, :key, value)}
   end
   ```

3. **Form Handling**:
   ```elixir
   def handle_event("save", %{"food" => food_params}, socket) do
     case Diets.update_food(socket.assigns.food, food_params) do
       {:ok, food} ->
         {:noreply,
          socket
          |> put_flash(:info, "Food updated successfully")
          |> push_patch(to: ~p"/foods")}
       {:error, %Ecto.Changeset{} = changeset} ->
         {:noreply, assign(socket, :form, to_form(changeset))}
     end
   end
   ```

This document should be consulted by AI agents before making any changes to ensure consistency and adherence to project standards.
