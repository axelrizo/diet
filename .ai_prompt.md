# AI Agent TDD Prompt Template

When working on this Phoenix/Elixir project, **ALWAYS** follow the Test-Driven Development (TDD) approach:

## üö® TDD MANDATORY WORKFLOW

### Red-Green-Refactor Cycle

**NEVER write production code without following this cycle:**

1. **üî¥ RED**: Write a failing test first
2. **üü¢ GREEN**: Write minimal code to make it pass
3. **üîµ REFACTOR**: Clean up while keeping tests green

## Context Awareness

- This is a Phoenix LiveView application for diet tracking
- Uses Elixir/Phoenix conventions and best practices
- Database: PostgreSQL with Ecto
- Frontend: LiveView with TailwindCSS
- **Development Method: STRICT TDD**

## Before Making ANY Changes

1. **Read TDD Rules**: Check `.ai_rules.md` and `.ai_config.json` files first
2. **Write Test First**: ALWAYS start with a failing test
3. **Follow Red-Green-Refactor**: Never skip this cycle
4. **Understand existing patterns**: Follow established conventions

## TDD Code Standards

- **Test First, Code Second**: No exceptions to this rule
- Follow Elixir naming conventions (snake_case for functions, PascalCase for modules)
- Use proper pattern matching and pipe operators
- Include proper error handling with {:ok, result} and {:error, reason} tuples
- **95%+ test coverage required**

## TDD LiveView Workflow

1. **Write LiveView test first**:
   ```elixir
   test "renders food form with validation errors", %{conn: conn} do
     {:ok, lv, _html} = live(conn, ~p"/foods/new")
     # Test the behavior you want
   end
   ```
2. **Watch it fail (RED)**
3. **Implement minimal LiveView code (GREEN)**
4. **Refactor for better design (REFACTOR)**

## TDD Database Operations

1. **Write context test first**:
   ```elixir
   describe "create_food/1" do
    test "creates a food when valid data" do
      valid_attrs = %{name: "Apple", protein: 0.3}
      assert {:ok, %Food{}} = Diets.create_food(valid_attrs)
    end
   end
   ```
2. **Write schema/changeset tests**
3. **Implement minimal code to pass**
4. **Refactor for optimization**

## TDD Testing Requirements

- **Use TDD cycle religiously** - Red, Green, Refactor
- **Test categories**: Unit (contexts, schemas), Integration (LiveView), Feature (workflows)
- **Use ExMachina** for test data generation
- **Use Mox** for external dependencies
- **Maintain 95%+ test coverage**
- **Test names should read like specifications**

## TDD Security and Performance

- **Test security concerns first**: Input validation, authorization
- **Test performance scenarios**: Large datasets, query optimization
- **Test edge cases and error conditions**
- **Test boundary conditions**

## TDD Anti-Patterns to Avoid

‚ùå **NEVER** write code before tests
‚ùå **NEVER** skip the failing test step  
‚ùå **NEVER** write multiple failing tests at once
‚ùå **NEVER** test implementation details
‚ùå **NEVER** ignore the refactor phase

## TDD Confirmation Required

**Before proceeding, you MUST confirm:**

- [ ] I understand this project uses STRICT TDD
- [ ] I will write failing tests first, always
- [ ] I will follow Red-Green-Refactor cycle
- [ ] I will not write any production code without a failing test
- [ ] I will maintain 95%+ test coverage
- [ ] I will test behavior, not implementation

**Please explicitly confirm you understand and will follow the TDD approach before making any changes.**
